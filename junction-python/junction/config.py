"""Junction client configuration."""

# This file is automatically generated with junction-api-gen. Do not edit!
import typing
import datetime


class Fraction(typing.TypedDict):
    """A fraction, expressed as a numerator and a denominator."""

    numerator: int
    denominator: int


class WeightedBackend(typing.TypedDict):
    weight: int
    hostname: str
    """The DNS Name to target/attach to"""

    name: str
    """The name of the Kubernetes Service"""

    namespace: str
    """The namespace of the Kubernetes service.
    FIXME(namespace): what should the semantic be when this is not specified:
    default, namespace of client, namespace of EZbake?"""

    port: int
    """The port number to target/attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""

    type: typing.Literal["DNS"] | typing.Literal["Service"]


class AttachmentDNS(typing.TypedDict):
    type: typing.Literal["DNS"]
    hostname: str
    """The DNS Name to target/attach to"""

    port: int
    """The port number to target/attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""


class AttachmentService(typing.TypedDict):
    type: typing.Literal["Service"]
    name: str
    """The name of the Kubernetes Service"""

    namespace: str
    """The namespace of the Kubernetes service.
    FIXME(namespace): what should the semantic be when this is not specified:
    default, namespace of client, namespace of EZbake?"""

    port: int
    """The port number of the Kubernetes service to target/
    attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""


Attachment = AttachmentDNS | AttachmentService


class SessionAffinityHashParam(typing.TypedDict):
    terminal: bool
    """Whether to stop immediately after hashing this value.

    This is useful if you want to try to hash a value, and then fall back
    to another as a default if it wasn't set."""

    name: str
    """The name of the header to use as hash input."""

    type: typing.Literal["Header"]


class RouteTimeouts(typing.TypedDict):
    """Defines timeouts that can be configured for a http Route. Specifying a zero
    value such as "0s" is interpreted as no timeout."""

    backend_request: datetime.timedelta
    """Specifies a timeout for an individual request from the gateway to a
    backend. This covers the time from when the request first starts being
    sent from the gateway to when the full response has been received from
    the backend.

    An entire client HTTP transaction with a gateway, covered by the Request
    timeout, may result in more than one call from the gateway to the
    destination backend, for example, if automatic retries are supported.

    Because the Request timeout encompasses the BackendRequest timeout, the
    value of BackendRequest must be <= the value of Request timeout."""

    request: datetime.timedelta
    """Specifies the maximum duration for a gateway to respond to an HTTP
    request. If the gateway has not been able to respond before this
    deadline is met, the gateway MUST return a timeout error.

    For example, setting the `rules.timeouts.request` field to the value
    `10s` will cause a timeout if a client request is taking longer than 10
    seconds to complete.

    This timeout is intended to cover as close to the whole request-response
    transaction as possible although an implementation MAY choose to start
    the timeout after the entire request stream has been received instead of
    immediately after the transaction is initiated by the client."""


class RouteRetryPolicy(typing.TypedDict):
    """Specifies a way of configuring client retry policy.

    ( Modelled on the forthcoming Gateway API type
    https://gateway-api.sigs.k8s.io/geps/gep-1731/ )"""

    codes: typing.List[int]
    attempts: int
    backoff: datetime.timedelta


class HeaderValue(typing.TypedDict):
    name: str
    """The name of the HTTP Header. Note header names are case insensitive.
    (See <https://tools.ietf.org/html/rfc7230#section-3.2>)."""

    value: str
    """The value of HTTP Header."""


class HeaderMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    name: str
    value: str


class HeaderMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    name: str
    value: str


HeaderMatch = HeaderMatchRegularExpression | HeaderMatchExact


class QueryParamMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    name: str
    value: str


class QueryParamMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    name: str
    value: str


QueryParamMatch = QueryParamMatchRegularExpression | QueryParamMatchExact


class PathMatchPrefix(typing.TypedDict):
    type: typing.Literal["Prefix"]
    value: str


class PathMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    value: str


class PathMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    value: str


PathMatch = PathMatchPrefix | PathMatchRegularExpression | PathMatchExact


class RouteMatch(typing.TypedDict):
    """Defines the predicate used to match requests to a given action. Multiple
    match types are ANDed together, i.e. the match will evaluate to true only if
    all conditions are satisfied.

    For example, the match below will match a HTTP request only if its path
    starts with `/foo` AND it contains the `version: v1` header:

    ```yaml
    match:
      path:
        value: "/foo"
      headers:
      - name: "version"
        value "v1"
    ```"""

    path: PathMatch
    """Specifies a HTTP request path matcher. If this field is not specified, a
    default prefix match on the "/" path is provided."""

    headers: typing.List[HeaderMatch]
    """Specifies HTTP request header matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified headers to
    select the route."""

    query_params: typing.List[QueryParamMatch]
    """Specifies HTTP query parameter matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified query
    parameters to select the route."""

    method: str
    """Specifies HTTP method matcher. When specified, this route will be
    matched only if the request has the specified method."""


class SessionAffinityPolicy(typing.TypedDict):
    hash_params: typing.List[SessionAffinityHashParam]


class RouteRule(typing.TypedDict):
    """Defines semantics for matching an HTTP request based on conditions
    (matches), processing it (filters), and forwarding the request to an API
    object (backendRefs)."""

    matches: typing.List[RouteMatch]
    """Defines conditions used for matching the rule against incoming HTTP
    requests. Each match is independent, i.e. this rule will be matched if
    **any** one of the matches is satisfied.

    For example, take the following matches configuration:

    ```yaml
    matches:
    - path:
        value: "/foo"
      headers:
      - name: "version"
        value: "v2"
    - path:
        value: "/v2/foo"
    ```

    For a request to match against this rule, a request must satisfy EITHER
    of the two conditions:

    - path prefixed with `/foo` AND contains the header `version: v2`
    - path prefix of `/v2/foo`

    See the documentation for RouteMatch on how to specify multiple match
    conditions that should be ANDed together.

    If no matches are specified, the default is a prefix path match on "/",
    which has the effect of matching every HTTP request."""

    timeouts: RouteTimeouts
    retry_policy: RouteRetryPolicy
    """How to retry any requests to this route."""

    backends: typing.List[WeightedBackend]
    """Where the traffic should route if this rule matches."""


class Route(typing.TypedDict):
    attachment: Attachment
    """The target for this route."""

    rules: typing.List[RouteRule]
    """The route rules that determine whether any URLs match."""


class LbPolicyRoundRobin(typing.TypedDict):
    type: typing.Literal["RoundRobin"]


class LbPolicyRingHash(typing.TypedDict):
    type: typing.Literal["RingHash"]
    min_ring_size: int
    """The minimum size of the hash ring"""

    hash_params: typing.List[SessionAffinityHashParam]
    """How to hash an outgoing request into the ring.

    Hash parameters are applied in order. If the request is missing an
    input, it has no effect on the final hash. Hashing stops when only when
    all polcies have been applied or a `terminal` policy matches part of an
    incoming request.

    This allows configuring a fallback-style hash, where the value of
    `HeaderA` gets used, falling back to the value of `HeaderB`.

    If no policies match, a random hash is generated for each request."""


class LbPolicyUnspecified(typing.TypedDict):
    type: typing.Literal["Unspecified"]


LbPolicy = LbPolicyRoundRobin | LbPolicyRingHash | LbPolicyUnspecified


class Backend(typing.TypedDict):
    attachment: Attachment
    lb: LbPolicy
    """The route rules that determine whether any URLs match."""
