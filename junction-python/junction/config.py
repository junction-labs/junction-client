"""Junction client configuration."""

# This file is automatically generated with junction-api-gen. Do not edit!
import typing
import datetime


class WeightedCluster(typing.TypedDict):
    name: str
    weight: int


RouteTarget = str | typing.List[WeightedCluster]


class Prefix(typing.TypedDict):
    type: str
    value: str


class RegularExpression(typing.TypedDict):
    type: str
    value: str


class Exact(typing.TypedDict):
    type: str
    value: str


PathMatch = Prefix | RegularExpression | Exact


class QueryParamMatch(typing.TypedDict):
    """Describes how to select a HTTP route by matching HTTP query parameters."""

    name: str
    type: str
    value: str


class ReplaceFullPath(typing.TypedDict):
    """Specifies the value with which to replace the full path of a request
    during a rewrite or redirect."""

    type: str
    replace_full_path: str


class ReplacePrefixMatch(typing.TypedDict):
    """Specifies the value with which to replace the prefix match of a request
    during a rewrite or redirect. For example, a request to "/foo/bar" with
    a prefix match of "/foo" and a ReplacePrefixMatch of "/xyz" would be
    modified to "/xyz/bar".

    Note that this matches the behavior of the PathPrefix match type. This
    matches full path elements. A path element refers to the list of labels
    in the path split by the `/` separator. When specified, a trailing `/`
    is ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would
    all match the prefix `/abc`, but the path `/abcd` would not.

    ReplacePrefixMatch is only compatible with a `PathPrefix` route match.

    Request Path | Prefix Match | Replace Prefix | Modified Path
    -------------|--------------|----------------|----------
    /foo/bar     | /foo         | /xyz           | /xyz/bar
    /foo/bar     | /foo         | /xyz/          | /xyz/bar
    /foo/bar     | /foo/        | /xyz           | /xyz/bar
    /foo/bar     | /foo/        | /xyz/          | /xyz/bar
    /foo         | /foo         | /xyz           | /xyz
    /foo/        | /foo         | /xyz           | /xyz/
    /foo/bar     | /foo         | <empty string> | /bar
    /foo/        | /foo         | <empty string> | /
    /foo         | /foo         | <empty string> | /
    /foo/        | /foo         | /              | /
    /foo         | /foo         | /              | /"""

    type: str
    replace_prefix_match: str


PathModifier = ReplaceFullPath | ReplacePrefixMatch


class HeaderMatch(typing.TypedDict):
    """Describes how to select a HTTP route by matching HTTP request headers.

    `name` is the name of the HTTP Header to be matched. Name matching is case
    insensitive. (See <https://tools.ietf.org/html/rfc7230#section-3.2>).

    If multiple entries specify equivalent header names, only the first entry
    with an equivalent name WILL be considered for a match. Subsequent entries
    with an equivalent header name WILL be ignored. Due to the
    case-insensitivity of header names, "foo" and "Foo" are considered
    equivalent."""

    name: str
    type: str
    value: str


class HeaderValue(typing.TypedDict):
    name: str
    """The name of the HTTP Header. Note header names are case insensitive.
    (See <https://tools.ietf.org/html/rfc7230#section-3.2>)."""

    value: str
    """The value of HTTP Header."""


class RouteTimeouts(typing.TypedDict):
    """Defines timeouts that can be configured for a http Route. Specifying a zero
    value such as "0s" is interpreted as no timeout."""

    backend_request: datetime.timedelta
    """Specifies a timeout for an individual request from the gateway to a
    backend. This covers the time from when the request first starts being
    sent from the gateway to when the full response has been received from
    the backend.

    An entire client HTTP transaction with a gateway, covered by the Request
    timeout, may result in more than one call from the gateway to the
    destination backend, for example, if automatic retries are supported.

    Because the Request timeout encompasses the BackendRequest timeout, the
    value of BackendRequest must be <= the value of Request timeout."""

    request: datetime.timedelta
    """Specifies the maximum duration for a gateway to respond to an HTTP
    request. If the gateway has not been able to respond before this
    deadline is met, the gateway MUST return a timeout error.

    For example, setting the `rules.timeouts.request` field to the value
    `10s` will cause a timeout if a client request is taking longer than 10
    seconds to complete.

    This timeout is intended to cover as close to the whole request-response
    transaction as possible although an implementation MAY choose to start
    the timeout after the entire request stream has been received instead of
    immediately after the transaction is initiated by the client."""


class RouteMatch(typing.TypedDict):
    """Defines the predicate used to match requests to a given action. Multiple
    match types are ANDed together, i.e. the match will evaluate to true only if
    all conditions are satisfied.

    For example, the match below will match a HTTP request only if its path
    starts with `/foo` AND it contains the `version: v1` header:

    ```yaml
    match:
      path:
        value: "/foo"
      headers:
      - name: "version"
        value "v1"
    ```"""

    path: PathMatch
    """Specifies a HTTP request path matcher. If this field is not specified, a
    default prefix match on the "/" path is provided."""

    headers: typing.List[HeaderMatch]
    """Specifies HTTP request header matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified headers to
    select the route."""

    query_params: typing.List[QueryParamMatch]
    """Specifies HTTP query parameter matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified query
    parameters to select the route."""

    method: str
    """Specifies HTTP method matcher. When specified, this route will be
    matched only if the request has the specified method."""


class Header(typing.TypedDict):
    type: str
    name: str


SessionAffinityHashParamType = Header


class SessionAffinityHashParam(typing.TypedDict):
    terminal: bool
    name: str
    type: str


SessionPersistenceCookieLifetimeType = (
    typing.Literal["Permanent"] | typing.Literal["Session"]
)


class SessionPersistenceCookieConfig(typing.TypedDict):
    """Provides configuration settings that are specific to cookie-based session
    persistence."""

    lifetime_type: SessionPersistenceCookieLifetimeType
    """Specifies whether the cookie has a permanent or session-based lifetime.
    A permanent cookie persists until its specified expiry time, defined by
    the Expires or Max-Age cookie attributes, while a session cookie is
    deleted when the current session ends.

    When set to "Permanent", AbsoluteTimeout indicates the cookie's lifetime
    via the Expires or Max-Age cookie attributes and is required.

    When set to "Session", AbsoluteTimeout indicates the absolute lifetime
    of the cookie and is optional."""


SessionPersistenceType = typing.Literal["Cookie"] | typing.Literal["Header"]


class SessionAffinityPolicy(typing.TypedDict):
    hash_params: typing.List[SessionAffinityHashParam]


class SessionPersistence(typing.TypedDict):
    """Defines and configures session persistence for the route rule."""

    session_name: str
    """Defines the name of the persistent session token which may be reflected
    in the cookie or the header. Avoid reusing session names to prevent
    unintended consequences, such as rejection or unpredictable behavior."""

    absolute_timeout: str
    """Defines the absolute timeout of the persistent session. Once the
    AbsoluteTimeout duration has elapsed, the session becomes invalid."""

    cookie_config: SessionPersistenceCookieConfig
    """Provides configuration settings that are specific to cookie-based
    session persistence."""

    idle_timeout: datetime.timedelta
    """Defines the idle timeout of the persistent session. Once the session has
    been idle for more than the specified IdleTimeout duration, the session
    becomes invalid."""

    type: SessionPersistenceType
    """Defines the type of session persistence such as through the use a header
    or cookie."""


class RequestHeaderFilter(typing.TypedDict):
    """Defines configuration for the RequestHeaderModifier filter."""

    set: typing.List[HeaderValue]
    """Overwrites the request with the given header (name, value) before the
    action. Note that the header names are case-insensitive (see
    <https://datatracker.ietf.org/doc/html/rfc2616#section-4.2>).

    Input: GET /foo HTTP/1.1 my-header: foo

    Config: set:
      - name: "my-header" value: "bar"

    Output: GET /foo HTTP/1.1 my-header: bar"""

    add: typing.List[HeaderValue]
    """Add adds the given header(s) (name, value) to the request before the
    action. It appends to any existing values associated with the header
    name.

    Input: GET /foo HTTP/1.1 my-header: foo

    Config: add:
      - name: "my-header" value: "bar"

    Output: GET /foo HTTP/1.1 my-header: foo my-header: bar"""

    remove: typing.List[str]
    """Remove the given header(s) from the HTTP request before the action. The
    value of Remove is a list of HTTP header names. Note that the header
    names are case-insensitive (see
    <https://datatracker.ietf.org/doc/html/rfc2616#section-4.2>).

    Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz

    Config: remove: ["my-header1", "my-header3"]

    Output: GET /foo HTTP/1.1 my-header2: bar"""


class RequestMirrorFilter(typing.TypedDict):
    """Defines configuration for the RequestMirror filter."""

    percent: int
    """Represents the percentage of requests that should be mirrored to
    BackendRef. Its minimum value is 0 (indicating 0% of requests) and its
    maximum value is 100 (indicating 100% of requests).

    Only one of Fraction or Percent may be specified. If neither field is
    specified, 100% of requests will be mirrored."""

    fraction: typing.Tuple[int, int]
    """Only one of Fraction or Percent may be specified. If neither field is
    specified, 100% of requests will be mirrored."""

    target: RouteTarget


class RequestRedirectFilter(typing.TypedDict):
    """Defines a filter that redirects a request. This filter MUST not be used on
    the same Route rule as a URL Rewrite filter."""

    scheme: str
    """The scheme to be used in the value of the `Location` header in the
    response. When empty, the scheme of the request is used.

    Scheme redirects can affect the port of the redirect, for more
    information, refer to the documentation for the port field of this
    filter."""

    hostname: str
    """The hostname to be used in the value of the `Location` header in the
    response. When empty, the hostname in the `Host` header of the request
    is used."""

    path: PathModifier
    """Defines parameters used to modify the path of the incoming request. The
    modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is."""

    port: int
    """The port to be used in the value of the `Location` header in the
    response.

    If no port is specified, the redirect port MUST be derived using the
    following rules:

    * If redirect scheme is not-empty, the redirect port MUST be the
      well-known port associated with the redirect scheme. Specifically
      "http" to port 80 and "https" to port 443. If the redirect scheme does
      not have a well-known port, the listener port of the Gateway SHOULD be
      used.
    * If redirect scheme is empty, the redirect port MUST be the Gateway
      Listener port.

    Will not add the port number in the 'Location' header in the following
    cases:

    * A Location header that will use HTTP (whether that is determined via
      the Listener protocol or the Scheme field) _and_ use port 80.
    * A Location header that will use HTTPS (whether that is determined via
      the Listener protocol or the Scheme field) _and_ use port 443."""

    status_code: int
    """The HTTP status code to be used in response."""


class UrlRewriteFilter(typing.TypedDict):
    """Defines a filter that modifies a request during forwarding. At most one of
    these filters may be used on a Route rule. This may not be used on the same
    Route rule as a RequestRedirect filter."""

    hostname: str
    """The value to be used to replace the Host header value during forwarding."""

    path: PathModifier
    """Defines a path rewrite."""


class RouteRetryPolicy(typing.TypedDict):
    """Specifies a way of configuring client retry policy.

    ( Modelled on the forthcoming Gateway API type
    https://gateway-api.sigs.k8s.io/geps/gep-1731/ )"""

    codes: typing.List[int]
    attempts: int
    backoff: datetime.timedelta


class RequestHeaderModifier(typing.TypedDict):
    """Defines a schema for a filter that modifies request headers."""

    type: str
    request_header_modifier: RequestHeaderFilter


class ResponseHeaderModifier(typing.TypedDict):
    """Defines a schema for a filter that modifies response headers."""

    type: str
    response_header_modifier: RequestHeaderFilter


class RequestMirror(typing.TypedDict):
    """Defines a schema for a filter that mirrors requests. Requests are sent
    to the specified destination, but responses from that destination are
    ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends."""

    type: str
    request_mirror: RequestMirrorFilter


class RequestRedirect(typing.TypedDict):
    """Defines a schema for a filter that responds to the request with an HTTP
    redirection."""

    type: str
    request_redirect: RequestRedirectFilter


class URLRewrite(typing.TypedDict):
    """Defines a schema for a filter that modifies a request during forwarding."""

    type: str
    url_rewrite: UrlRewriteFilter


RouteFilter = (
    RequestHeaderModifier
    | ResponseHeaderModifier
    | RequestMirror
    | RequestRedirect
    | URLRewrite
)


class RouteRule(typing.TypedDict):
    """Defines semantics for matching an HTTP request based on conditions
    (matches), processing it (filters), and forwarding the request to an API
    object (backendRefs)."""

    matches: typing.List[RouteMatch]
    """Defines conditions used for matching the rule against incoming HTTP
    requests. Each match is independent, i.e. this rule will be matched if
    **any** one of the matches is satisfied.

    For example, take the following matches configuration:

    ```yaml
    matches:
    - path:
        value: "/foo"
      headers:
      - name: "version"
        value: "v2"
    - path:
        value: "/v2/foo"
    ```

    For a request to match against this rule, a request must satisfy EITHER
    of the two conditions:

    - path prefixed with `/foo` AND contains the header `version: v2`
    - path prefix of `/v2/foo`

    See the documentation for RouteMatch on how to specify multiple match
    conditions that should be ANDed together.

    If no matches are specified, the default is a prefix path match on "/",
    which has the effect of matching every HTTP request."""

    filters: typing.List[RouteFilter]
    """Define the filters that are applied to requests that match this rule.

    The effects of ordering of multiple behaviors are currently unspecified.

    Specifying the same filter multiple times is not supported unless
    explicitly indicated in the filter.

    All filters are compatible with each other except for the URLRewrite and
    RequestRedirect filters, which may not be combined."""

    session_persistence: SessionPersistence
    timeouts: RouteTimeouts
    session_affinity: SessionAffinityPolicy
    retry_policy: RouteRetryPolicy
    target: RouteTarget


class Route(typing.TypedDict):
    hostnames: typing.List[str]
    """The domains that this applies to. Domains are matched against the
    incoming authority of any URL."""

    rules: typing.List[RouteRule]
    """The route rules that determine whether any URLs match."""
