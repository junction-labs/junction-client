"""Junction client configuration."""

# This file is automatically generated with junction-api-gen. Do not edit!
import typing
import datetime


class Fraction(typing.TypedDict):
    """A fraction, expressed as a numerator and a denominator."""

    numerator: int
    denominator: int


class WeightedBackend(typing.TypedDict):
    weight: int
    hostname: str
    """The DNS Name to target/attach to"""

    name: str
    """The name of the Kubernetes Service"""

    namespace: str
    """The namespace of the Kubernetes service.
    FIXME(namespace): what should the semantic be when this is not specified:
    default, namespace of client, namespace of EZbake?"""

    port: int
    """The port number to target/attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""

    type: typing.Literal["DNS"] | typing.Literal["Service"]


class AttachmentDNS(typing.TypedDict):
    type: typing.Literal["DNS"]
    hostname: str
    """The DNS Name to target/attach to"""

    port: int
    """The port number to target/attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""


class AttachmentService(typing.TypedDict):
    type: typing.Literal["Service"]
    name: str
    """The name of the Kubernetes Service"""

    namespace: str
    """The namespace of the Kubernetes service.
    FIXME(namespace): what should the semantic be when this is not specified:
    default, namespace of client, namespace of EZbake?"""

    port: int
    """The port number of the Kubernetes service to target/
    attach to.

    When attaching policies, if it is not specified, the
    attachment will apply to all connections that don't have a specific
    port specified.

    When being used to lookup a backend after a matched rule,
    if it is not specified then it will use the same port as the incoming request"""


Attachment = AttachmentDNS | AttachmentService


class SessionAffinityHashParam(typing.TypedDict):
    terminal: bool
    """Whether to stop immediately after hashing this value.

    This is useful if you want to try to hash a value, and then fall back
    to another as a default if it wasn't set."""

    name: str
    """The name of the header to use as hash input."""

    type: typing.Literal["Header"]


class RouteTimeouts(typing.TypedDict):
    """Defines timeouts that can be configured for a http Route. Specifying a zero
    value such as "0s" is interpreted as no timeout."""

    backend_request: datetime.timedelta
    """Specifies a timeout for an individual request from the gateway to a
    backend. This covers the time from when the request first starts being
    sent from the gateway to when the full response has been received from
    the backend.

    An entire client HTTP transaction with a gateway, covered by the Request
    timeout, may result in more than one call from the gateway to the
    destination backend, for example, if automatic retries are supported.

    Because the Request timeout encompasses the BackendRequest timeout, the
    value of BackendRequest must be <= the value of Request timeout."""

    request: datetime.timedelta
    """Specifies the maximum duration for a gateway to respond to an HTTP
    request. If the gateway has not been able to respond before this
    deadline is met, the gateway MUST return a timeout error.

    For example, setting the `rules.timeouts.request` field to the value
    `10s` will cause a timeout if a client request is taking longer than 10
    seconds to complete.

    This timeout is intended to cover as close to the whole request-response
    transaction as possible although an implementation MAY choose to start
    the timeout after the entire request stream has been received instead of
    immediately after the transaction is initiated by the client."""


class RouteRetryPolicy(typing.TypedDict):
    """Specifies a way of configuring client retry policy.

    ( Modelled on the forthcoming Gateway API type
    https://gateway-api.sigs.k8s.io/geps/gep-1731/ )"""

    codes: typing.List[int]
    attempts: int
    backoff: datetime.timedelta


class HeaderValue(typing.TypedDict):
    name: str
    """The name of the HTTP Header. Note header names are case insensitive.
    (See <https://tools.ietf.org/html/rfc7230#section-3.2>)."""

    value: str
    """The value of HTTP Header."""


class HeaderMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    name: str
    value: str


class HeaderMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    name: str
    value: str


HeaderMatch = HeaderMatchRegularExpression | HeaderMatchExact


class QueryParamMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    name: str
    value: str


class QueryParamMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    name: str
    value: str


QueryParamMatch = QueryParamMatchRegularExpression | QueryParamMatchExact


class PathMatchPrefix(typing.TypedDict):
    type: typing.Literal["Prefix"]
    value: str


class PathMatchRegularExpression(typing.TypedDict):
    type: typing.Literal["RegularExpression"]
    value: str


class PathMatchExact(typing.TypedDict):
    type: typing.Literal["Exact"]
    value: str


PathMatch = PathMatchPrefix | PathMatchRegularExpression | PathMatchExact


class RouteMatch(typing.TypedDict):
    """Defines the predicate used to match requests to a given action. Multiple
    match types are ANDed together, i.e. the match will evaluate to true only if
    all conditions are satisfied.

    For example, the match below will match a HTTP request only if its path
    starts with `/foo` AND it contains the `version: v1` header:

    ```yaml
    match:
      path:
        value: "/foo"
      headers:
      - name: "version"
        value "v1"
    ```"""

    path: PathMatch
    """Specifies a HTTP request path matcher. If this field is not specified, a
    default prefix match on the "/" path is provided."""

    headers: typing.List[HeaderMatch]
    """Specifies HTTP request header matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified headers to
    select the route."""

    query_params: typing.List[QueryParamMatch]
    """Specifies HTTP query parameter matchers. Multiple match values are ANDed
    together, meaning, a request must match all the specified query
    parameters to select the route."""

    method: str
    """Specifies HTTP method matcher. When specified, this route will be
    matched only if the request has the specified method."""


class HeaderFilter(typing.TypedDict):
    """Defines configuration for the RequestHeaderModifier filter."""

    set: typing.List[HeaderValue]
    """Overwrites the request with the given header (name, value) before the
    action. Note that the header names are case-insensitive (see
    <https://datatracker.ietf.org/doc/html/rfc2616#section-4.2>).

    Input: GET /foo HTTP/1.1 my-header: foo

    Config: set:
      - name: "my-header" value: "bar"

    Output: GET /foo HTTP/1.1 my-header: bar"""

    add: typing.List[HeaderValue]
    """Add adds the given header(s) (name, value) to the request before the
    action. It appends to any existing values associated with the header
    name.

    Input: GET /foo HTTP/1.1 my-header: foo

    Config: add:
      - name: "my-header" value: "bar"

    Output: GET /foo HTTP/1.1 my-header: foo my-header: bar"""

    remove: typing.List[str]
    """Remove the given header(s) from the HTTP request before the action. The
    value of Remove is a list of HTTP header names. Note that the header
    names are case-insensitive (see
    <https://datatracker.ietf.org/doc/html/rfc2616#section-4.2>).

    Input: GET /foo HTTP/1.1 my-header1: foo my-header2: bar my-header3: baz

    Config: remove: ["my-header1", "my-header3"]

    Output: GET /foo HTTP/1.1 my-header2: bar"""


class RequestMirrorFilter(typing.TypedDict):
    """Defines configuration for the RequestMirror filter."""

    percent: int
    """Represents the percentage of requests that should be mirrored to
    BackendRef. Its minimum value is 0 (indicating 0% of requests) and its
    maximum value is 100 (indicating 100% of requests).

    Only one of Fraction or Percent may be specified. If neither field is
    specified, 100% of requests will be mirrored."""

    fraction: Fraction
    """Only one of Fraction or Percent may be specified. If neither field is
    specified, 100% of requests will be mirrored."""

    backend: Attachment


class PathModifierReplaceFullPath(typing.TypedDict):
    """Specifies the value with which to replace the full path of a request
    during a rewrite or redirect."""

    type: typing.Literal["ReplaceFullPath"]
    replace_full_path: str
    """The value to replace the path with."""


class PathModifierReplacePrefixMatch(typing.TypedDict):
    """Specifies the value with which to replace the prefix match of a request
    during a rewrite or redirect. For example, a request to "/foo/bar" with
    a prefix match of "/foo" and a ReplacePrefixMatch of "/xyz" would be
    modified to "/xyz/bar".

    Note that this matches the behavior of the PathPrefix match type. This
    matches full path elements. A path element refers to the list of labels
    in the path split by the `/` separator. When specified, a trailing `/`
    is ignored. For example, the paths `/abc`, `/abc/`, and `/abc/def` would
    all match the prefix `/abc`, but the path `/abcd` would not.

    ReplacePrefixMatch is only compatible with a `PathPrefix` route match.

    Request Path | Prefix Match | Replace Prefix | Modified Path
    -------------|--------------|----------------|----------
    /foo/bar     | /foo         | /xyz           | /xyz/bar
    /foo/bar     | /foo         | /xyz/          | /xyz/bar
    /foo/bar     | /foo/        | /xyz           | /xyz/bar
    /foo/bar     | /foo/        | /xyz/          | /xyz/bar
    /foo         | /foo         | /xyz           | /xyz
    /foo/        | /foo         | /xyz           | /xyz/
    /foo/bar     | /foo         | <empty string> | /bar
    /foo/        | /foo         | <empty string> | /
    /foo         | /foo         | <empty string> | /
    /foo/        | /foo         | /              | /
    /foo         | /foo         | /              | /"""

    type: typing.Literal["ReplacePrefixMatch"]
    replace_prefix_match: str


PathModifier = PathModifierReplaceFullPath | PathModifierReplacePrefixMatch


class RequestRedirectFilter(typing.TypedDict):
    """Defines a filter that redirects a request. This filter MUST not be used on
    the same Route rule as a URL Rewrite filter."""

    scheme: str
    """The scheme to be used in the value of the `Location` header in the
    response. When empty, the scheme of the request is used.

    Scheme redirects can affect the port of the redirect, for more
    information, refer to the documentation for the port field of this
    filter."""

    hostname: str
    """The hostname to be used in the value of the `Location` header in the
    response. When empty, the hostname in the `Host` header of the request
    is used."""

    path: PathModifier
    """Defines parameters used to modify the path of the incoming request. The
    modified path is then used to construct the `Location` header. When
    empty, the request path is used as-is."""

    port: int
    """The port to be used in the value of the `Location` header in the
    response.

    If no port is specified, the redirect port MUST be derived using the
    following rules:

    * If redirect scheme is not-empty, the redirect port MUST be the
      well-known port associated with the redirect scheme. Specifically
      "http" to port 80 and "https" to port 443. If the redirect scheme does
      not have a well-known port, the listener port of the Gateway SHOULD be
      used.
    * If redirect scheme is empty, the redirect port MUST be the Gateway
      Listener port.

    Will not add the port number in the 'Location' header in the following
    cases:

    * A Location header that will use HTTP (whether that is determined via
      the Listener protocol or the Scheme field) _and_ use port 80.
    * A Location header that will use HTTPS (whether that is determined via
      the Listener protocol or the Scheme field) _and_ use port 443."""

    status_code: int
    """The HTTP status code to be used in response."""


class UrlRewriteFilter(typing.TypedDict):
    """Defines a filter that modifies a request during forwarding. At most one of
    these filters may be used on a Route rule. This may not be used on the same
    Route rule as a RequestRedirect filter."""

    hostname: str
    """The value to be used to replace the Host header value during forwarding."""

    path: PathModifier
    """Defines a path rewrite."""


class RouteFilterRequestHeaderModifier(typing.TypedDict):
    """Defines a schema for a filter that modifies request headers."""

    type: typing.Literal["RequestHeaderModifier"]
    request_header_modifier: HeaderFilter
    """A Header filter."""


class RouteFilterResponseHeaderModifier(typing.TypedDict):
    """Defines a schema for a filter that modifies response headers."""

    type: typing.Literal["ResponseHeaderModifier"]
    response_header_modifier: HeaderFilter
    """A Header filter."""


class RouteFilterRequestMirror(typing.TypedDict):
    """Defines a schema for a filter that mirrors requests. Requests are sent
    to the specified destination, but responses from that destination are
    ignored.

    This filter can be used multiple times within the same rule. Note that
    not all implementations will be able to support mirroring to multiple
    backends."""

    type: typing.Literal["RequestMirror"]
    request_mirror: RequestMirrorFilter


class RouteFilterRequestRedirect(typing.TypedDict):
    """Defines a schema for a filter that responds to the request with an HTTP
    redirection."""

    type: typing.Literal["RequestRedirect"]
    request_redirect: RequestRedirectFilter
    """A redirect filter."""


class RouteFilterURLRewrite(typing.TypedDict):
    """Defines a schema for a filter that modifies a request during forwarding."""

    type: typing.Literal["URLRewrite"]
    url_rewrite: UrlRewriteFilter
    """A URL rewrite filter."""


RouteFilter = (
    RouteFilterRequestHeaderModifier
    | RouteFilterResponseHeaderModifier
    | RouteFilterRequestMirror
    | RouteFilterRequestRedirect
    | RouteFilterURLRewrite
)


class SessionAffinityPolicy(typing.TypedDict):
    hash_params: typing.List[SessionAffinityHashParam]


class RouteRule(typing.TypedDict):
    """Defines semantics for matching an HTTP request based on conditions
    (matches), processing it (filters), and forwarding the request to an API
    object (backendRefs)."""

    matches: typing.List[RouteMatch]
    """Defines conditions used for matching the rule against incoming HTTP
    requests. Each match is independent, i.e. this rule will be matched if
    **any** one of the matches is satisfied.

    For example, take the following matches configuration:

    ```yaml
    matches:
    - path:
        value: "/foo"
      headers:
      - name: "version"
        value: "v2"
    - path:
        value: "/v2/foo"
    ```

    For a request to match against this rule, a request must satisfy EITHER
    of the two conditions:

    - path prefixed with `/foo` AND contains the header `version: v2`
    - path prefix of `/v2/foo`

    See the documentation for RouteMatch on how to specify multiple match
    conditions that should be ANDed together.

    If no matches are specified, the default is a prefix path match on "/",
    which has the effect of matching every HTTP request."""

    filters: typing.List[RouteFilter]
    """Define the filters that are applied to requests that match this rule.

    The effects of ordering of multiple behaviors are currently unspecified.

    Specifying the same filter multiple times is not supported unless
    explicitly indicated in the filter.

    All filters are compatible with each other except for the URLRewrite and
    RequestRedirect filters, which may not be combined."""

    timeouts: RouteTimeouts
    session_affinity: SessionAffinityPolicy
    retry_policy: RouteRetryPolicy
    """How to retry any requests to this route."""

    backends: typing.List[WeightedBackend]
    """Where the traffic should route if this rule matches."""


class Route(typing.TypedDict):
    attachment: Attachment
    """The target for this route."""

    rules: typing.List[RouteRule]
    """The route rules that determine whether any URLs match."""


class LbPolicyRoundRobin(typing.TypedDict):
    type: typing.Literal["RoundRobin"]


class LbPolicyRingHash(typing.TypedDict):
    type: typing.Literal["RingHash"]
    min_ring_size: int
    """The minimum size of the hash ring"""

    hash_params: typing.List[SessionAffinityHashParam]
    """How to hash an outgoing request into the ring.

    Hash parameters are applied in order. If the request is missing an
    input, it has no effect on the final hash. Hashing stops when only when
    all polcies have been applied or a `terminal` policy matches part of an
    incoming request.

    This allows configuring a fallback-style hash, where the value of
    `HeaderA` gets used, falling back to the value of `HeaderB`.

    If no policies match, a random hash is generated for each request."""


class LbPolicyUnspecified(typing.TypedDict):
    type: typing.Literal["Unspecified"]


LbPolicy = LbPolicyRoundRobin | LbPolicyRingHash | LbPolicyUnspecified


class Backend(typing.TypedDict):
    attachment: Attachment
    lb: LbPolicy
    """The route rules that determine whether any URLs match."""
