{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>An xDS dynamically-configurable API load-balancer library.</p>"},{"location":"#what-is-it","title":"What is it?","text":"<p>Junction is a library that allows you to dynamically configure application  level HTTP routing, load balancing, and resilience by writing a few lines of configuration and dynamically pushing it to your client. Imagine all of the features of a rich HTTP proxy that's as easy to work with as the HTTP library you're already using. </p> <p>Junction does that by pulling endpoints and configuration from an xDS  control plane, as follows:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510                 \n\u2502    Client Service   \u2502    \n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Existing \u2502 Junction \u25c4\u2500\u2500\u2500\u2500\u2524    xDS    \u2502\n\u2502   HTTP   \u2502  Client  \u2502    \u2502  Control  \u2502\n\u2502 Library  \u2502 Library  \u2502    \u2502   Plane   \u2502\n\u2514\u2500\u2500\u2500\u2500\u252c\u2500\u252c\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u25b2\u2500\u2500\u2500\u2500\u2500\u2518\n     \u2502 \u2502                         \u2502      \n     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u2502      \n\u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Your   \u2502  \u2502  Your   \u2502   \u2502  K8s API  \u2502\n\u2502 Service \u2502  \u2502 Service \u2502   \u2502  Server   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Junction is developed by Junction Labs.</p>"},{"location":"#features","title":"Features","text":"<p>Today, Junction allows you to dynamically configure:</p> <ul> <li>Routing traffic based on HTTP method, path, headers, or query parameters</li> <li>Timeouts</li> <li>Retries</li> <li>Weighted traffic splitting</li> <li>Load balancing (Ring-Hash or WRR)</li> </ul> <p>On our roadmap are features like:</p> <ul> <li>multi-cluster federation</li> <li>zone-based load balancing</li> <li>rate limiting</li> <li>subsetting</li> <li>circuit breaking</li> </ul>"},{"location":"#supported-xds-control-planes","title":"Supported xDS Control Planes","text":"<p>Today the only xDS server the junction-client regression tests against is ezbake. Ezbake is a simple xDS control plane for Junction, which uses the gateway_api to support dynamic configuration. <code>ezbake</code> runs in a Kubernetes cluster, watches its running services, and runs as an xDS control plane to drive the Junction client.</p>"},{"location":"#supported-languages-and-http-libraries","title":"Supported languages and HTTP Libraries","text":"Language Integrated HTTP Libraries Rust None Python requests, urllib3 Node.js fetch()"},{"location":"#getting-started","title":"Getting started","text":"<p>See here</p>"},{"location":"#project-status","title":"Project status","text":"<p>Junction is alpha software, developed in the open. We're still iterating rapidly on our client facing API, and our integration into xDS. At this stage you should  expect occasional breaking changes as the library evolves. </p>"},{"location":"#license","title":"License","text":"<p>The Junction client is Apache 2.0 licensed.</p>"},{"location":"#contact-us","title":"Contact Us","text":"<p>info@junctionlabs.io</p>"},{"location":"getting-started/","title":"Overview","text":"<p>There are 3 steps to getting Junction running.</p>"},{"location":"getting-started/#step-1-set-up-a-control-plane","title":"Step 1 - Set up a control plane","text":"<p>Today the only xDS server the junction-client regression tests against is ezbake. Ezbake is a simple xDS control plane for Junction, which uses the gateway_api to support dynamic configuration. <code>ezbake</code> runs in a Kubernetes cluster, watches its running services, and runs as an xDS control plane to drive the Junction client.</p> <ul> <li>Set up ezbake</li> </ul>"},{"location":"getting-started/#step-2-install-the-junction-client","title":"Step 2 - Install the Junction client","text":"<p>Here you just need to read the guide for the languages you are using.</p> <ul> <li>Node.js</li> <li>Python</li> <li>Rust</li> </ul>"},{"location":"getting-started/#step-3-configure-your-client-behavior","title":"Step 3 - Configure your client behavior","text":"<p>Finally you must configure Junction to shape your clients behavior.</p> <ul> <li>Configuring Junction</li> </ul>"},{"location":"getting-started/configuring-junction/","title":"Configuring Junction","text":"<p>Junction enables testing to validate behavior with the same configuration that eventually gets used dynamically. In this last part of the getting started guide, we walk through how the same configuration can be used in three different ways.</p> <ul> <li>Static configuration for unit testing</li> <li>Static configuration with dynamic IP's for Integration Testing</li> <li>Dynamic configuration with ezbake</li> </ul>"},{"location":"getting-started/configuring-junction/#defining-our-config","title":"Defining our config","text":"<p>To start, we need to define a configuration. Here we have a route on the hostname <code>jct-simple-app.default.svc.cluster.local</code>, which sends all requests matching the path <code>/v2/user</code> to a test service called <code>jct-simple-app-v2</code>, putting in place a retry policy as well:</p> <pre><code>import junction\nimport junction.config\nimport typing\n\nmy_service = {\"type\": \"kube\", \"name\": \"jct-simple-app\", \"namespace\": \"default\"}\nmy_test_service = {\"type\": \"kube\", \"name\": \"jct-simple-app-v2\", \"namespace\": \"default\"}\n\nretry_policy: junction.config.RouteRetry = {\n    \"attempts\": 3,\n    \"backoff\": 0.5,\n    \"codes\": [500, 503],\n}\n\nroutes: typing.List[junction.config.Route] = [\n    {\n        \"id\": \"jct-simple-app-routes\",\n        \"hostnames\": [\"jct-simple-app.default.svc.cluster.local\"],\n        \"rules\": [\n            {\n                \"backends\": [{**my_test_service, \"port\": 8008}],\n                \"retry\": retry_policy,\n                \"matches\": [{\"path\": {\"value\": \"/v2/users\"}}],\n            },\n            {\n                \"backends\": [{**my_service, \"port\": 8008}],\n                \"retry\": retry_policy,\n            },\n        ],\n    },\n]\n</code></pre>"},{"location":"getting-started/configuring-junction/#static-configuration-for-unit-testing","title":"Static configuration for unit testing","text":"<p>The first step in testing a configuration is unit tests. Junction provides the check_route method, which lets you test how a specific request will get processed by it's rule:</p> <pre><code># assert that requests with no path go to the cool service like normal\n(_, _, matched_backend) = junction.check_route(\n    routes, \"GET\", \"http://jct-simple-app.default.svc.cluster.local\", {}\n)\nassert matched_backend[\"name\"] == \"jct-simple-app\"\n\n# assert that requests to /v2/users go to the cool-test service\n(_, _, matched_backend) = junction.check_route(\n    routes, \"GET\", \"http://jct-simple-app.default.svc.cluster.local/v2/users\", {}\n)\nassert matched_backend[\"name\"] == \"jct-simple-app-v2\"\n</code></pre>"},{"location":"getting-started/configuring-junction/#static-configuration-for-pre-deployment-testing","title":"Static configuration for pre-deployment testing","text":"<p>Before we roll out the configuration dynamically, we probably want to see it work in a real HTTP client. To allow this mode, all clients can be configured with static routes and backends, and use those rather than what comes back from the control plane.</p> <p>Then: <pre><code>import junction.requests as requests\n\nsession = junction.requests.Session(\n    static_routes=routes\n)\nr1 = session.get(\"http://jct-simple-app.default.svc.cluster.local\")\nr2 = session.get(\"http://jct-simple-app.default.svc.cluster.local/v2/users\")\n# both go to expected service\nprint(r1.text)\nprint(r2.text)\n</code></pre></p>"},{"location":"getting-started/configuring-junction/#dynamic-configuration-with-ezbake","title":"Dynamic configuration with ezbake","text":"<p>The final step is deploying the configuration to the control plane feeding all clients in the cluster. Junction provides integrations with EZBake to make this simple. EZBake uses the Gateway API HTTPRoute to specify routes, and so junction provides a method that allows configuration to be dumped to a file, that can either be directly executed with <code>kubectl apply -f</code>, or put in whatever GitOps mechanism you use to roll out configuration. </p> <pre><code>for route in routes:\n    print(\"---\")\n    print(junction.dump_kube_route(route=route, namespace=\"default\"))\n</code></pre>"},{"location":"getting-started/ezbake/","title":"Setting Up Control Plane - EZBake","text":"<p>Ezbake is a simple xDS control plane for Junction, which uses the gateway_api to support dynamic configuration. <code>ezbake</code> runs in a Kubernetes cluster, watches its running services, and runs as an xDS control plane to drive the Junction client.</p>"},{"location":"getting-started/ezbake/#simple-installation","title":"Simple Installation","text":"<p>The simplest installation is as follows, which first sets up the Kubernetes Gateway API CRD, and then sets up ezbake as a 2 pod deployment in its own namespace (junction), with permissions to monitor all services, endpoints, and gateway API config in the cluster.</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/experimental-install.yaml\nkubectl apply -f https://github.com/junction-labs/ezbake/releases/latest/download/install-for-cluster.yml\n</code></pre> <p>Now, to communicate with ezbake, all clients will need the <code>JUNCTION_ADS_SERVER</code> environment  variable set as follows:</p> <pre><code>export JUNCTION_ADS_SERVER=\"grpc://ezbake.junction.svc.cluster.local:8008\"\n</code></pre> <p>[!NOTE]</p> <p><code>ezbake</code> returns Pod IPs directly without any NAT, so if your cluster isn't configured to allow talking directly to Pod IPs from outside the cluster, any client you run outside the cluster won't be able to connect to any backends.  Notably, local clusters created with <code>k3d</code>, <code>kind</code>, and Docker Desktop behave this way.</p>"},{"location":"getting-started/ezbake/#uninstalling","title":"Uninstalling","text":"<p>To uninstall, run <code>kubectl delete</code> on the Gateway APIs and the objects that <code>ezbake</code> installed:</p> <pre><code>kubectl delete -f https://github.com/junction-labs/ezbake/releases/latest/download/install-for-cluster.yml\nkubectl delete -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/experimental-install.yaml\n</code></pre>"},{"location":"getting-started/ezbake/#more-advanced-installation","title":"More advanced installation","text":""},{"location":"getting-started/ezbake/#deploying-to-kubernetes-in-a-single-namespace","title":"Deploying to Kubernetes in a Single Namespace","text":"<p>On a cluster where you only have access to a single namespace, you can still run <code>ezbake</code>. </p> <p>First you do need  your cluster admin install the Gateway APIs by following the official instructions.</p> <pre><code>kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.2.0/experimental-install.yaml\n</code></pre> <p>Next, create a service account that has permissions to list and watch the API server. The <code>ServiceAccount</code>, <code>Role</code> and <code>RoleBinding</code> in <code>scripts/install-for-namespace-admin.yml</code> list all of the required privileges. Feel free to copy that template, replace <code>foo</code> with your namespace, and apply it to the cluster:</p> <pre><code># run this as a cluster admin\nsed 's/foo/$YOUR_NAMESPACE_HERE/' &lt; scripts/install-for-namespace-admin.yml &gt; ezbake-role.yml\nkubectl apply -f ezbake-role.yml\n</code></pre> <p>Deploy <code>ezbake</code> as you would any other Deployment, making sure to run it as the <code>ServiceAccount</code> created with permissions. The template in <code>install-for-namespace.yml</code> gives an example, and can be used as a template to get started.</p> <pre><code>sed 's/foo/$YOUR_NAMESPACE_HERE/' &lt; scripts/install-for-namespace.yml &gt; ezbake.yml\nkubectl apply -f ezbake.yml\n</code></pre>"},{"location":"getting-started/node/","title":"Installing Client - Node.js","text":"<p>The Junction client is on NPM.  This means all you need to do is:</p> <pre><code>npm install @junction-labs/client\n</code></pre> <p>If you are using Next.js, you will also have to add the following to <code>next.config.ts</code>:</p> <pre><code>const nextConfig: NextConfig = {\n  serverExternalPackages: ['@junction-labs/client'],\n};\n</code></pre>"},{"location":"getting-started/node/#fetch","title":"fetch","text":"<p>Junction provides a <code>fetch()</code> method, that's fully compatible with the Fetch standard, that uses Junction under the hood to route requests and handle retries.</p> <pre><code>const junction = require(\"@junction-labs/client\");\n\nvar response = await junction.fetch(\"http://httpbin.default.svc.cluster.local:8008/status/418\");\nconsole.log(response.status);\n// 418\nconsole.log(await response.text());\n//\n//    -=[ teapot ]=-\n//\n//       _...._\n//     .'  _ _ `.\n//    | .\"` ^ `\". _,\n//    \\_;`\"---\"`|//\n//      |       ;/\n//      \\_     _/\n//        `\"\"\"`\n</code></pre>"},{"location":"getting-started/node/#direct-use","title":"Direct use","text":"<p>To examine and debug configuration, you can instantiate a Junction client and use it to directly call <code>resolveHttp</code>. </p> <pre><code>const junction = require(\"@junction-labs/client\");\n\nconst client = await junction.Client.build({\n  adsServer: \"grpc://192.168.194.201:8008\",\n});\n\nconsole.log(await client.resolveHttp({\"url\": \"https://httpbin.org\"));\n// Endpoint {\n//   scheme: 'https',\n//   sockAddr: { address: '50.19.58.113', port: 443 },\n//   hostname: 'httpbin.org',\n//   retry: undefined,\n//   timeouts: undefined\n// }\n</code></pre> <p>APIs for dumping Route and Backend configuration are not yet available.</p> <p>For more, see the full API reference.</p>"},{"location":"getting-started/python/","title":"Installing Client - Python","text":"<p>The Junction client is on PyPi.  This means all you need to do is:</p> <pre><code>pip install junction-python\n</code></pre>"},{"location":"getting-started/python/#requests","title":"Requests","text":"<p>Junction is fully compatible with the Requests library, just with a different import:</p> <pre><code>import junction.requests as requests\n\nsession = requests.Session()\nsession.get(\"http://jct-simple-app.default.svc.cluster.local:8008\")\n</code></pre> <p>The Junction client used by a session is also available on that session as a field, and can be used to inspect and debug configuration.</p> <pre><code>junction_client = session.junction\njunction_client.dump_routes()\n</code></pre> <p>For more, see the full API reference.</p>"},{"location":"getting-started/python/#urllib3","title":"Urllib3","text":"<p>Junction is fully compatible with the Urllib3 library, just with a different import:</p> <pre><code>from junction.urllib3 import PoolManager\nhttp = PoolManager()\nhttp.urlopen(\"GET\", \"http://jct-simple-app.default.svc.cluster.local:8008\")\n</code></pre> <p>The Junction client used by each PoolManager is also available as a field and can be used to inspect and debug configuration.</p> <pre><code>junction_client = http.junction\njunction_client.dump_routes()\n</code></pre> <p>For more, see the full API reference.</p>"},{"location":"getting-started/python/#direct-use","title":"Direct use","text":"<p>Junction is generally intended to be used indirectly, though the interfaces that that match your HTTP client. However, using the Junction client directly can be useful to inspect and debug your configuration..</p> <p>The <code>junction</code> module makes the default Junction client available for introspection, and individual Sessions and PoolManagers make their active clients available.</p> <pre><code>import junction\n\nclient = junction.default_client()\nclient.dump_routes()\n</code></pre> <p>For more, see the full API reference.</p>"},{"location":"getting-started/rust/","title":"Installing Client - Rust","text":"<p>The core of Junction is written in Rust and is available in the <code>junction-core</code> crate. At the moment, we don't have an integration with an HTTP library available, but you can use the core client to dynamically fetch config and resolve addresses.</p> <p>See the <code>examples</code> directory for an example of how to use junction to resolve an address.</p> <p>For more, see the full API reference.</p>"},{"location":"guides/","title":"Index","text":"<p>These are deeper dives on particular topics:</p> <ul> <li>Configuring Routes and Backends</li> <li>Interactively Debugging</li> </ul>"},{"location":"guides/configuration/","title":"Configuring Routes and Backends","text":""},{"location":"guides/configuration/#routes","title":"Routes","text":""},{"location":"guides/configuration/#weighting-backends","title":"Weighting Backends","text":""},{"location":"guides/configuration/#timeouts","title":"Timeouts","text":""},{"location":"guides/configuration/#retries","title":"Retries","text":""},{"location":"guides/configuration/#backends","title":"Backends","text":""},{"location":"guides/configuration/#kubernetes-backends","title":"Kubernetes Backends","text":""},{"location":"guides/configuration/#dns-backends","title":"DNS Backends","text":""},{"location":"guides/configuration/#load-balancing-round-robin","title":"Load Balancing: Round Robin","text":""},{"location":"guides/configuration/#load-balancing-ring-hash","title":"Load Balancing: Ring Hash","text":""},{"location":"guides/debugging/","title":"Interactively Debugging","text":""},{"location":"overview/core-concepts/","title":"Concepts","text":""},{"location":"overview/core-concepts/#resolution","title":"Resolution","text":"<p>At its heart Junction replaces DNS, except rather than  go from hostname to an IP, it goes from hostname and header/query params to a list of IPs, and dynamic configuration such as retry policies, timeouts, rate limits, and mTLS certs.</p> <p>To implement this lookup Junction has two layers of indirection which allow for configuration: Routes and Backends. The lookup flow then looks like the following:</p> <pre><code>     Request                                              \n        ?\u2500\u2500\u2500\u25ba Lookup: Hostname + header/querystring params   \n        \u2502                                                 \n        \u25bc                                                 \n      Route \u2500\u2500\u2500\u2500\u2500\u2500\u25ba Also determines: timeouts, retry policy\n        ?\u2500\u2500\u2500\u25ba Lookup: Weighting, Mirroring                   \n        \u2502                                                 \n        \u25bc                                                 \n Service Backend \u2500\u25ba Also determines: mTLS policy           \n        ?\u2500\u2500\u2500\u25ba Lookup: load balancing algorithm               \n        \u2502                                                 \n        \u25bc                                                 \n  IP address list                                         \n</code></pre> <p>For those coming from the Kubernetes Gateway API, we choose the names routes and backends to be exactly the same concepts as it's routes and BackendRefs. However because Junction is very much targeted as service to service communication, some things like ParentRefs are not carried across.</p>"},{"location":"overview/core-concepts/#routes","title":"Routes","text":"<p>A route is the client facing half of Junction, and contains most of the things you'd traditionally find in a hand-rolled HTTP client - timeouts, retries, URL rewriting and more. Routes match requests based on their hostname, method, URL, and headers. </p>"},{"location":"overview/core-concepts/#hostnames","title":"Hostnames","text":"<p>Junction's main purpose is service discovery, and just like with DNS, the major input to a lookup is a hostname. However, unlike DNS which needs to handle the scale of the Internet, Junction is aimed at problems where the entire set of names can be kept in memory of a single server (at 1,000 bytes per record, 1,000,000 records is just 1 GiB).  Thus in Junction there is no logic about subdomains. Rather, you set up a Route on any hostname you want, and a Junction will match it. </p> <p>One thing Junction does support is wildcard prefixes \"*.mydomain.com\", to allow a single route to pick up dynamically allocated hostnames.</p>"},{"location":"overview/core-concepts/#services","title":"Services","text":"<p>The Junction API is built around the idea that you're always routing requests to a Service, which is an abstract representation of a place you might want traffic to go. A Service can be anything, but to use one in Junction you need a way to uniquely specify it. That could be anything from a DNS name someone else has already set up to a Kubernetes Service in a cluster you've connected to Junction.</p>"},{"location":"overview/core-concepts/#backends","title":"Backends","text":"<p>A Backend is a single port on a Service. Backend configuration gives you control over the things you'd normally configure in a reverse proxy or a traditional load balancer.</p>"},{"location":"reference/api/","title":"API reference","text":"<p>The API reference contains detailed descriptions of all public functions and objects. It's the best place to look if you need information on a specific function.</p> <ul> <li>Node.js</li> <li>Python</li> <li>Rust</li> </ul>"}]}